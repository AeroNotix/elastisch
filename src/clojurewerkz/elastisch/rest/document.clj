;; Copyright (c) 2011-2014 Michael S. Klishin, Alex Petrov, and the ClojureWerkz Team
;;
;; The use and distribution terms for this software are covered by the
;; Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;; which can be found in the file epl-v10.html at the root of this distribution.
;; By using this software in any fashion, you are agreeing to be bound by
;; the terms of this license.
;; You must not remove this notice, or any other, from this software.

(ns clojurewerkz.elastisch.rest.document
  "Key operations on documents: indexing, search, deletion, etc"
  (:refer-clojure :exclude [get replace count sort])
  (:require [clojurewerkz.elastisch.rest :as rest]
            [cheshire.core :as json]
            [clojure.string :as string]
            [clojure.set :refer :all]
            [clojurewerkz.elastisch.rest.utils :refer [join-names]]
            [clojurewerkz.elastisch.arguments :as ar]
            [clojurewerkz.elastisch.rest.response :refer [not-found? hits-from]])
  (:import clojurewerkz.elastisch.rest.Connection))

;;
;; API
;;

(defn create
  "Adds document to the search index. Document id will be generated automatically.

   Options:

     * :id (string): unique document id. If not provided, it will be generated by ElasticSearch
     * :timestamp (string): document timestamp either as millis since the epoch,
                                          or, in the configured date format
     * :ttl (long): document TTL in milliseconds. Must be > 0
     * :refresh (boolean, default: false): should a refresh be executed post this index operation?
     * :version (long): document version
     * :version-type (string, default: \"internal\"): \"internal\" or \"external\"
     * :content-type (string): document content type
     * :routing (string): controls the shard routing of the request. Using this value to hash the shard
                          and not the id
     * :percolate (string): the percolate query to use to reduce the percolated queries that are going to run against this doc.
                           Can be set to \"*\" which means \"all queries\"
     * :parent (string): parent document id

   Examples:

   (require '[clojurewerkz.elastisch.rest.document :as doc])

   (doc/create \"people\" \"person\" {:first-name \"John\" :last-name \"Appleseed\" :age 28})

   (doc/create \"people\" \"person\" {:first-name \"John\" :last-name \"Appleseed\" :age 28} :id \"1825c5432775b8d1a477acfae57e91ac8c767aed\")"
  ([index mapping-type document & args]
     (rest/post (rest/mapping-type-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                       index mapping-type) :body document :query-params (ar/->opts args))))

(defn put
  "Creates or updates a document in the search index, using the provided document id"
  ([index mapping-type id document]
     (rest/put (rest/record-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                index mapping-type id) :body document))
  ([index mapping-type id document & args]
     (rest/put (rest/record-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                index mapping-type id) :body document :query-params (ar/->opts args))))

(defn update-with-script
  "Updates a document using a script"
  ([index mapping-type id script]
     (rest/post (rest/record-update-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                        index mapping-type id) :body {:script script}))
  ([index mapping-type id script params]
     (rest/post (rest/record-update-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                        index mapping-type id)
                :body {:script script :params params})))

(defn get
  "Fetches and returns a document by id or nil if it does not exist.

   Examples:

   (require '[clojurewerkz.elastisch.rest.document :as doc])

   (doc/get \"people\" \"person\" \"1825c5432775b8d1a477acfae57e91ac8c767aed\")"
  [index mapping-type id & args]
  (let [result (rest/get (rest/record-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                          index mapping-type id) :query-params (ar/->opts args))]
    (if (not-found? result)
      nil
      result)))

(defn delete
  "Deletes document from the index."
  ([index mapping-type id]
     (rest/delete (rest/record-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                   index mapping-type id)))
  ([index mapping-type id & args]
     (rest/delete (rest/record-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                   index mapping-type id) :query-params (ar/->opts args))))

(defn present?
  "Returns true if a document with the given id is present in the provided index
   with the given mapping type."
  [index mapping-type id]
  (not (nil? (get index mapping-type id))))

(defn multi-get
  "Multi get returns only documents that are found (exist).

   Queries can passed as a collection of maps with three keys: :_index,
   :_type and :_id:

   (doc/multi-get [{:_index index-name :_type mapping-type :_id \"1\"}
                   {:_index index-name :_type mapping-type :_id \"2\"}])


   2-argument version accepts an index name that eliminates the need to include
   :_index in every query map:

   (doc/multi-get index-name [{:_type mapping-type :_id \"1\"}
                              {:_type mapping-type :_id \"2\"}])

   3-argument version also accepts a mapping type that eliminates the need to include
   :_type in every query map:

   (doc/multi-get index-name mapping-type [{:_id \"1\"}
                                           {:_id \"2\"}])"
  ([query]
     (let [results (rest/post (rest/index-mget-url ^Connection clojurewerkz.elastisch.rest/*endpoint*)
                              :body {:docs query})]
       (filter :found (:docs results))))
  ([index query]
     (let [results (rest/post (rest/index-mget-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                                   index)
                              :body {:docs query})]
       (filter :found (:docs results))))
  ([index mapping-type query]
     (let [results (rest/post (rest/index-mget-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                                   index mapping-type)
                              :body {:docs query})]
       (filter :found (:docs results)))))

(defn search
  "Performs a search query across one or more indexes and one or more mapping types.

   Passing index name as \"_all\" means searching across all indexes.

   Examples:

   (require '[clojurewerkz.elastisch.rest.document :as doc])
   (require '[clojurewerkz.elastisch.query :as q])

   (doc/search \"people\" \"person\" :query (q/prefix :username \"appl\"))"
  [index mapping-type & args]
  (let [opts (ar/->opts args)
        qk   [:search_type :scroll :routing :preference]
        qp   (select-keys opts qk)
        body (apply dissoc (concat [opts] qk))]
    (rest/post (rest/search-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                (join-names index)
                                (join-names mapping-type))
               :body body
               :query-params qp)))

(defn search-all-types
  "Performs a search query across one or more indexes and all mapping types."
  [index & args]
  (let [opts (ar/->opts args)
        qk   [:search_type :scroll :routing :preference]
        qp   (select-keys opts qk)
        body (apply dissoc (concat [opts] qk))]
    (rest/post (rest/search-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                (join-names index))
               :body body
               :query-params qp)))

(defn search-all-indexes-and-types
  "Performs a search query across all indexes and all mapping types. This may put very high load on your
   ElasticSearch cluster so use this function with care."
  [& args]
  (let [opts (ar/->opts args)
        qk   [:search_type :scroll :routing :preference]
        qp   (select-keys opts qk)
        body (apply dissoc (concat [opts] qk))]
    (rest/post (rest/search-url ^Connection clojurewerkz.elastisch.rest/*endpoint*)
               :body body
               :query-params qp)))

(defn scroll
  "Performs a scroll query, fetching the next page of results from a
   query given a scroll id"
  [scroll-id & args]
  (let [opts (ar/->opts args)
        qk   [:search_type :scroll :routing :preference]
        qp   (assoc (select-keys opts qk) :scroll_id scroll-id)
        body (apply dissoc (concat [opts] qk))]
    (rest/get (rest/scroll-url ^Connection clojurewerkz.elastisch.rest/*endpoint*)
              :query-params qp)))

(defn scroll-seq
  "Returns a lazy sequence of all documents for a given scroll query"
  [prev-resp]
  (let [hits      (hits-from prev-resp)
        scroll-id (:_scroll_id prev-resp)]
    (if (seq hits)
      (concat hits (lazy-seq (scroll-seq (scroll scroll-id :scroll "1m"))))
      hits)))

(defn replace
  "Replaces document with given id with a new one"
  [index mapping-type id document]
  (delete index mapping-type id)
  (put index mapping-type id document))


(defn count
  "Performs a count query.

   Examples:

   (require '[clojurewerkz.elastisch.rest.document :as doc])
   (require '[clojurewerkz.elastisch.query :as q])

   (doc/count \"people\" \"person\")
   (doc/count \"people\" \"person\" (q/prefix :username \"appl\"))"
  ([index mapping-type]
     (rest/get (rest/count-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                               (join-names index) (join-names mapping-type))))
  ([index mapping-type query]
     (rest/post (rest/count-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                (join-names index) (join-names mapping-type)) :body {:query query}))
  ([index mapping-type query & args]
     (rest/post (rest/count-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                (join-names index) (join-names mapping-type))
                :query-params (select-keys (ar/->opts args) [:df :analyzer :default_operator])
                :body {:query query})))

(def ^{:doc "Optional parameters that all query-based delete functions share"
       :const true}
  optional-delete-query-parameters [:df :analyzer :default_operator :consistency])

(defn delete-by-query
  "Performs a delete-by-query operation."
  ([index mapping-type query]
     (rest/delete (rest/delete-by-query-url
                   ^Connection clojurewerkz.elastisch.rest/*endpoint*
                   (join-names index) (join-names mapping-type)) :body {:query query}))
  ([index mapping-type query & args]
     (rest/delete (rest/delete-by-query-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                            (join-names index) (join-names mapping-type))
                  :query-params (select-keys (ar/->opts args) optional-delete-query-parameters)
                  :body {:query query})))

(defn delete-by-query-across-all-types
  "Performs a delete-by-query operation across all mapping types."
  ([index query]
     (rest/delete (rest/delete-by-query-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                            (join-names index)) :body {:query query}))
  ([index query & args]
     (rest/delete (rest/delete-by-query-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                            (join-names index))
                  :query-params (select-keys (ar/->opts args) optional-delete-query-parameters)
                  :body {:query query})))

(defn delete-by-query-across-all-indexes-and-types
  "Performs a delete-by-query operation across all indexes and mapping types.
   This may put very high load on your ElasticSearch cluster so use this function with care."
  ([query]
     (rest/delete (rest/delete-by-query-url ^Connection clojurewerkz.elastisch.rest/*endpoint*) :body {:query query}))
  ([query & args]
     (rest/delete (rest/delete-by-query-url ^Connection clojurewerkz.elastisch.rest/*endpoint*)
                  :query-params (select-keys (ar/->opts args) optional-delete-query-parameters)
                  :body {:query query})))


(defn more-like-this
  "Performs a More Like This (MLT) query."
  [index mapping-type id & args]
  (rest/get (rest/more-like-this-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                     index mapping-type id)
            :query-params (ar/->opts args)))

(defn validate-query
  "Validates a query without actually executing it. Has the same API as clojurewerkz.elastisch.rest.document/search
   but does not take the mapping type parameter."
  [index query & args]
  (rest/get (rest/query-validation-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                       index)
            :body (json/encode {:query query}) :query-params (ar/->opts args)))


(defn analyze 
  "Examples:

   (require '[clojurewerkz.elastisch.rest.document :as doc])

   (doc/analyze \"foo bar baz\")
   (doc/analyze \"foo bar baz\" :index \"some-index-name\")
   (doc/analyze \"foo bar baz\" :analyzer \"whitespace\")
   (doc/analyze \"foo bar baz\" :index \"some-index-name\" :field \"some-field-name\")"
  ([text & args]
     (let [opts (ar/->opts args)]
       (rest/get (rest/analyze-url ^Connection clojurewerkz.elastisch.rest/*endpoint*
                                   (:index opts))
                 :query-params (assoc opts :text text)))))
